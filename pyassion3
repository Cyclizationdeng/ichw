def main():
    def change(x):
        t = []
        t.append(x%m)
        t.append(x//m)
        return t

    def brick(u,v,x):
        brick = []
        for i in range(u):
            for j in range(v):
                brick.append(x + i + m * j)
        return brick

    def judgebrick(u,v,x,p):
        if (change(x)[0]+u-1) >= m or (change(x,)[1]+v-1) >= n:
            return False
        for i in brick(u,v,x):
            for j in range(p):
                if i in solution[j]:
                    return False
        return True

    def conflict(x,p,solution):
        for i in range(p):
            if x in solution[i]:
                return True
        return False

    def solve(x,p):
        if p == m*n//(a*b):
            print(solution)
            allsolution.append(solution[:])
        else:
            if conflict(x,p,solution):
                solve(x+1,p)
            if not conflict(x,p,solution):
                if judgebrick(a,b,x,p):
                    solution[p] = brick(a,b,x)
                    solve(x+1,p+1)
                if judgebrick(b,a,x,p):
                    solution[p] = brick(b,a,x)
                    solve(x+1,p+1)
    m = int(input('write down the lenth of the tile: '))
    n = int(input('write down the wedth of the tile: '))
    a = int(input('write down one lenth of the brick: '))
    b = int(input('write down another lenth of the brick: '))
    solution = [0 for i in range(m*n//(a*b))]
    allsolution = []
    solve(0,0)

    import turtle 
        print('总数='+str(len(allsolution)))
        num = turtle.numinput('decide on which filling approach you wanna see',\
            'ranging from 1-'+str(len(allsolution)),1,minval=1,maxval=len(allsolution))
        k = int(num)
        turtle.speed(0)
        turtle.penup()
        turtle.goto(-m*30,-n*30)
        turtle.pendown()
        turtle.pensize(6)
        for i in range(2):
            turtle.fd(m*60)
            turtle.lt(90)
            turtle.fd(n*60)
            turtle.lt(90)
        turtle.lt(90)
        turtle.pensize(0)
        turtle.color('blue')
        for i in range(1,m):
            turtle.penup()
            turtle.goto(-m*30+60*i,-n*30)
            turtle.pendown()
            turtle.fd(n*60)
        turtle.rt(90)
        for i in range(1,n):
            turtle.penup()
            turtle.goto(-m*30,-n*30+60*i)
            turtle.pendown()
            turtle.fd(m*60)
        turtle.pensize(2)
        for i in range(m):
            for j in range(n):
                turtle.penup()
                turtle.goto(i*60+30-m*30,j*60+30-n*30)
                turtle.pendown()
                turtle.write(i+m*j)
        turtle.color('black')
        turtle.pensize(4)
        for element in allsolution[k-1]:
            element.sort()
            x1 = change(element[0])[0]
            y1 = change(element[0])[1]
            x2 = change(element[-1])[0]
            y2 = change(element[-1])[1]
            turtle.penup()
            turtle.goto(x1*60-m*30,y1*60-n*30)
            turtle.pendown()
            turtle.goto(x2*60+60-m*30,y1*60-n*30)
            turtle.goto(x2*60+60-m*30,y2*60+60-n*30)
            turtle.goto(x1*60-m*30,y2*60+60-n*30)
            turtle.goto(x1*60-m*30,y1*60-n*30)
        turtle.done()        
    if __name__ == '__main__':
    main()

